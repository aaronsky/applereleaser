/**
Copyright (C) 2020 Aaron Sky.

This file is part of Cider, a tool for automating submission
of apps to Apple's App Stores.

Cider is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Cider is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Cider.  If not, see <http://www.gnu.org/licenses/>.
*/

package env

import (
	"fmt"
	"os"
	"testing"

	"github.com/cidertool/cider/pkg/config"
	"github.com/cidertool/cider/pkg/context"
	"github.com/stretchr/testify/assert"
)

func TestEnv(t *testing.T) {
	t.Parallel()

	ctx := context.New(config.Project{})
	pipe := Pipe{}

	var err error

	assert.Equal(t, "loading environment variables", pipe.String())

	err = pipe.Run(ctx)
	assert.Error(t, err)

	// Pass with ASC_KEY_ID but fail on ASC_ISSUER_ID
	err = os.Setenv("ASC_KEY_ID", "TEST")
	assert.NoError(t, err)
	err = pipe.Run(ctx)
	assert.Error(t, err)

	// Pass with ASC_ISSUER_ID but fail on ASC_PRIVATE_KEY_PATH
	err = os.Setenv("ASC_ISSUER_ID", "TEST")
	assert.NoError(t, err)
	err = pipe.Run(ctx)
	assert.Error(t, err)

	// Check ASC_PRIVATE_KEY_PATH but fail because nothing exists at that path
	err = os.Setenv("ASC_PRIVATE_KEY_PATH", "TEST")
	assert.NoError(t, err)
	err = pipe.Run(ctx)
	assert.Error(t, err)

	// Check ASC_PRIVATE_KEY_PATH but silently fail because it isn't required
	err = os.Setenv("TEST", "path/to/no/file")
	assert.NoError(t, err)
	env, err := loadEnvFromPath("TEST", false)
	assert.NoError(t, err)
	assert.Empty(t, env)

	file, err := os.CreateTemp("", "fake_key")
	if err != nil {
		assert.FailNow(t, "temp file creation produced an error", err)
	}

	defer rmFile(file)

	// Check ASC_PRIVATE_KEY_PATH but fail because the contents of the file do not contain a real key
	err = os.Setenv("ASC_PRIVATE_KEY_PATH", file.Name())
	assert.NoError(t, err)
	err = pipe.Run(ctx)
	assert.Error(t, err)

	// This key is a mock key generated by the following command:
	//
	//   openssl ecparam -name prime256v1 -genkey -noout | openssl pkcs8 -topk8 -nocrypt -out key.pem
	//
	// This will generate the ASN.1 PKCS#8 representation of the private key needed
	// to create a valid token. If you are looking at this test to see how to make a key,
	// reference Apple's documentation on this subject instead.
	//
	// https://developer.apple.com/documentation/appstoreconnectapi/creating_api_keys_for_app_store_connect_api
	key := `
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgELiCwZa9oGedoUR7
8Vr36M6WOkEBGZh2YsUVL0kCIJ6hRANCAASQtP/ZdZBW6UdwJeyz09ws2nx5OOUA
tra43bY9mLeVK0zrTn/3jvjTHEdD3HcRJgau1jshXG4IHXSW9yXj9x3V
-----END PRIVATE KEY-----
`
	_, err = file.WriteString(key)
	assert.NoError(t, err)

	// Pass with ASC_PRIVATE_KEY_PATH, and create the credentials object
	err = pipe.Run(ctx)
	assert.NoError(t, err)
	assert.NotNil(t, ctx.Credentials)
}

// rmFile closes an open descriptor.
func rmFile(f *os.File) {
	if err := os.Remove(f.Name()); err != nil {
		// nolint: forbidigo
		fmt.Println(err)
	}
}
